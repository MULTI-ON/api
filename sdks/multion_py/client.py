# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .environment import MultionApiEnvironment
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .resources.low_level.client import AsyncLowLevelClient, LowLevelClient
from .types.browse_output import BrowseOutput
from .types.http_validation_error import HttpValidationError
from .types.message import Message
from .types.retrieve_output import RetrieveOutput

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class MultionApi:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: MultionApiEnvironment = MultionApiEnvironment.DEFAULT,
        api_key: str,
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            api_key=api_key,
            httpx_client=httpx.Client(timeout=timeout) if httpx_client is None else httpx_client,
        )
        self.low_level = LowLevelClient(client_wrapper=self._client_wrapper)

    def browse(
        self,
        *,
        cmd: typing.Optional[str] = OMIT,
        url: str,
        session_id: typing.Optional[str] = OMIT,
        max_steps: typing.Optional[int] = OMIT,
        stream: typing.Optional[bool] = OMIT,
        include_screenshot: typing.Optional[bool] = OMIT,
    ) -> BrowseOutput:
        """
        Browse the web using MultiOn.

        Parameters:
            - cmd: typing.Optional[str].

            - url: str.

            - session_id: typing.Optional[str].

            - max_steps: typing.Optional[int].

            - stream: typing.Optional[bool].

            - include_screenshot: typing.Optional[bool].
        ---
        from multion.client import MultionApi

        client = MultionApi(
            api_key="YOUR_API_KEY",
        )
        client.browse(
            url="url",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"url": url}
        if cmd is not OMIT:
            _request["cmd"] = cmd
        if session_id is not OMIT:
            _request["session_id"] = session_id
        if max_steps is not OMIT:
            _request["maxSteps"] = max_steps
        if stream is not OMIT:
            _request["stream"] = stream
        if include_screenshot is not OMIT:
            _request["includeScreenshot"] = include_screenshot
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/browse"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(BrowseOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def retrieve(self, session_id: str, *, request: Message) -> RetrieveOutput:
        """
        This function is used to retrieve information from a website based on user query.

        Parameters:
            - session_id: str.

            - request: Message.
        ---
        from multion import Message
        from multion.client import MultionApi

        client = MultionApi(
            api_key="YOUR_API_KEY",
        )
        client.retrieve(
            session_id="session_id",
            request=Message(
                url="url",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/retrieve/{session_id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncMultionApi:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: MultionApiEnvironment = MultionApiEnvironment.DEFAULT,
        api_key: str,
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            api_key=api_key,
            httpx_client=httpx.AsyncClient(timeout=timeout) if httpx_client is None else httpx_client,
        )
        self.low_level = AsyncLowLevelClient(client_wrapper=self._client_wrapper)

    async def browse(
        self,
        *,
        cmd: typing.Optional[str] = OMIT,
        url: str,
        session_id: typing.Optional[str] = OMIT,
        max_steps: typing.Optional[int] = OMIT,
        stream: typing.Optional[bool] = OMIT,
        include_screenshot: typing.Optional[bool] = OMIT,
    ) -> BrowseOutput:
        """
        Browse the web using MultiOn.

        Parameters:
            - cmd: typing.Optional[str].

            - url: str.

            - session_id: typing.Optional[str].

            - max_steps: typing.Optional[int].

            - stream: typing.Optional[bool].

            - include_screenshot: typing.Optional[bool].
        ---
        from multion.client import AsyncMultionApi

        client = AsyncMultionApi(
            api_key="YOUR_API_KEY",
        )
        await client.browse(
            url="url",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"url": url}
        if cmd is not OMIT:
            _request["cmd"] = cmd
        if session_id is not OMIT:
            _request["session_id"] = session_id
        if max_steps is not OMIT:
            _request["maxSteps"] = max_steps
        if stream is not OMIT:
            _request["stream"] = stream
        if include_screenshot is not OMIT:
            _request["includeScreenshot"] = include_screenshot
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/browse"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(BrowseOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def retrieve(self, session_id: str, *, request: Message) -> RetrieveOutput:
        """
        This function is used to retrieve information from a website based on user query.

        Parameters:
            - session_id: str.

            - request: Message.
        ---
        from multion import Message
        from multion.client import AsyncMultionApi

        client = AsyncMultionApi(
            api_key="YOUR_API_KEY",
        )
        await client.retrieve(
            session_id="session_id",
            request=Message(
                url="url",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/retrieve/{session_id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveOutput, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: MultionApiEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
